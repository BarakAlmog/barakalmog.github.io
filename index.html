<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Portfolio | Airtable CRM 3D Visualization</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        margin: 0;
        overflow: hidden;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background: #000;
      }

      canvas {
        display: block;
      }

      #info {
        position: absolute;
        top: 30px;
        left: 30px;
        color: #fff;
        background: rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(10px);
        padding: 20px 25px;
        border-radius: 15px;
        font-size: 14px;
        z-index: 100;
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      }

      #info h2 {
        margin: 0 0 15px 0;
        font-size: 22px;
        font-weight: 600;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      .control-group {
        margin-bottom: 12px;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .control-icon {
        display: inline-block;
        width: 30px;
        height: 30px;
        background: rgba(102, 126, 234, 0.2);
        border-radius: 6px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
      }

      .control-text {
        color: rgba(255, 255, 255, 0.8);
        font-size: 13px;
      }

      #loading {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: white;
        font-size: 24px;
        z-index: 1000;
        text-align: center;
      }

      .loader {
        width: 50px;
        height: 50px;
        border: 3px solid rgba(255, 255, 255, 0.1);
        border-top-color: #667eea;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin: 20px auto;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      #click-hint {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: white;
        font-size: 18px;
        background: rgba(0, 0, 0, 0.7);
        padding: 20px 40px;
        border-radius: 10px;
        pointer-events: none;
        opacity: 1;
        transition: opacity 0.3s;
        z-index: 50;
      }

      #click-hint.hidden {
        opacity: 0;
      }
    </style>
  </head>
  <body>
    <div id="loading">
      <div class="loader"></div>
      Loading Experience...
    </div>

    <div id="click-hint">Press any key to start exploring</div>

    <div id="info">
      <h2>PORTFOLIO EXPLORER</h2>
      <div class="control-group">
        <div class="control-icon">⌨️</div>
        <div class="control-text">WASD - Move around</div>
      </div>
      <div class="control-group">
        <div class="control-icon">←→</div>
        <div class="control-text">Arrow Left/Right - Turn</div>
      </div>
      <div class="control-group">
        <div class="control-icon">↑↓</div>
        <div class="control-text">Arrow Up/Down - Look up/down</div>
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
      // Scene setup
      const scene = new THREE.Scene()
      scene.background = new THREE.Color(0x0a0a1a)
      scene.fog = new THREE.FogExp2(0x0a0a1a, 0.015)

      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )
      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true })
      renderer.setSize(window.innerWidth, window.innerHeight)
      renderer.setPixelRatio(window.devicePixelRatio)
      renderer.shadowMap.enabled = true
      renderer.shadowMap.type = THREE.PCFSoftShadowMap
      renderer.toneMapping = THREE.ACESFilmicToneMapping
      renderer.toneMappingExposure = 1.8
      document.body.appendChild(renderer.domElement)

      // Camera setup - positioned to view the dashboard
      camera.position.set(0, 1.6, 8)
      camera.rotation.order = 'YXZ'

      let cameraRotation = { x: 0, y: 0 }
      const moveSpeed = 0.15
      const turnSpeed = 0.03
      const lookSpeed = 0.02
      const cameraHeight = 1.6 // Fixed ground level height

      // Enhanced Lighting System
      const ambientLight = new THREE.AmbientLight(0x6666ff, 0.3)
      scene.add(ambientLight)

      // Key light
      const keyLight = new THREE.DirectionalLight(0x667eea, 1.5)
      keyLight.position.set(5, 8, 5)
      keyLight.castShadow = true
      keyLight.shadow.mapSize.width = 2048
      keyLight.shadow.mapSize.height = 2048
      keyLight.shadow.camera.near = 0.5
      keyLight.shadow.camera.far = 50
      keyLight.shadow.camera.left = -15
      keyLight.shadow.camera.right = 15
      keyLight.shadow.camera.top = 15
      keyLight.shadow.camera.bottom = -15
      scene.add(keyLight)

      // Accent lights
      const accentLight1 = new THREE.PointLight(0x667eea, 2, 20)
      accentLight1.position.set(-5, 3, -3)
      scene.add(accentLight1)

      const accentLight2 = new THREE.PointLight(0x764ba2, 2, 20)
      accentLight2.position.set(5, 3, -3)
      scene.add(accentLight2)

      // Rim light
      const rimLight = new THREE.SpotLight(0xff00ff, 1.5, 30, Math.PI / 6)
      rimLight.position.set(0, 10, -10)
      rimLight.target.position.set(0, 2, 0)
      scene.add(rimLight)
      scene.add(rimLight.target)

      // Ground - Futuristic grid floor
      const createGridFloor = () => {
        const gridGroup = new THREE.Group()

        // Main floor
        const floorGeometry = new THREE.PlaneGeometry(50, 50)
        const floorMaterial = new THREE.MeshStandardMaterial({
          color: 0x0a0a1a,
          roughness: 0.7,
          metalness: 0.3,
          transparent: true,
          opacity: 0.9,
        })
        const floor = new THREE.Mesh(floorGeometry, floorMaterial)
        floor.rotation.x = -Math.PI / 2
        floor.receiveShadow = true
        gridGroup.add(floor)

        // Glowing grid lines
        const gridSize = 50
        const divisions = 50
        const gridHelper = new THREE.GridHelper(gridSize, divisions, 0x667eea, 0x667eea)
        gridHelper.material.opacity = 0.15
        gridHelper.material.transparent = true
        gridHelper.material.emissive = new THREE.Color(0x667eea)
        gridHelper.material.emissiveIntensity = 0.3
        gridGroup.add(gridHelper)

        return gridGroup
      }
      scene.add(createGridFloor())

      // Load the Airtable dashboard image and create the main display
      const textureLoader = new THREE.TextureLoader()

      const dashboardGroup = new THREE.Group()
      dashboardGroup.position.set(0, 2.5, 0)

      // Create image data URL from the screenshot
      const imageData =
        'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg=='

      // Main dashboard screen
      const screenWidth = 7
      const screenHeight = 4

      // Create holographic frame
      const frameThickness = 0.08
      const frameDepth = 0.15

      const frameMaterial = new THREE.MeshStandardMaterial({
        color: 0x667eea,
        roughness: 0.2,
        metalness: 0.8,
        emissive: 0x667eea,
        emissiveIntensity: 0.5,
      })

      // Frame pieces
      const topFrame = new THREE.Mesh(
        new THREE.BoxGeometry(
          screenWidth + frameThickness * 2,
          frameThickness,
          frameDepth
        ),
        frameMaterial
      )
      topFrame.position.y = screenHeight / 2 + frameThickness / 2
      dashboardGroup.add(topFrame)

      const bottomFrame = new THREE.Mesh(
        new THREE.BoxGeometry(
          screenWidth + frameThickness * 2,
          frameThickness,
          frameDepth
        ),
        frameMaterial
      )
      bottomFrame.position.y = -screenHeight / 2 - frameThickness / 2
      dashboardGroup.add(bottomFrame)

      const leftFrame = new THREE.Mesh(
        new THREE.BoxGeometry(frameThickness, screenHeight, frameDepth),
        frameMaterial
      )
      leftFrame.position.x = -screenWidth / 2 - frameThickness / 2
      dashboardGroup.add(leftFrame)

      const rightFrame = new THREE.Mesh(
        new THREE.BoxGeometry(frameThickness, screenHeight, frameDepth),
        frameMaterial
      )
      rightFrame.position.x = screenWidth / 2 + frameThickness / 2
      dashboardGroup.add(rightFrame)

      // Screen with image texture - using ShaderMaterial for ripple effect
      const screenGeometry = new THREE.PlaneGeometry(screenWidth, screenHeight)

      // Shader material with ripple distortion
      const screenMaterial = new THREE.ShaderMaterial({
        uniforms: {
          uTexture: { value: null },
          uRippleCenter: { value: new THREE.Vector2(0.5, 0.5) },
          uRippleStrength: { value: 0.0 },
          uRippleRadius: { value: 0.0 },
        },
        vertexShader: `
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform sampler2D uTexture;
          uniform vec2 uRippleCenter;
          uniform float uRippleStrength;
          uniform float uRippleRadius;
          varying vec2 vUv;

          void main() {
            vec2 uv = vUv;

            // Calculate distance from ripple center
            float dist = distance(uv, uRippleCenter);

            // Create ripple wave effect
            if (dist < uRippleRadius && uRippleStrength > 0.0) {
              float ripple = sin((dist - uRippleRadius) * 30.0) * uRippleStrength;
              float falloff = 1.0 - (dist / uRippleRadius);
              ripple *= falloff;

              // Distort UVs based on ripple
              vec2 direction = normalize(uv - uRippleCenter);
              uv += direction * ripple * 0.03;
            }

            gl_FragColor = texture2D(uTexture, uv);
          }
        `,
        toneMapped: false,
      })

      const screen = new THREE.Mesh(screenGeometry, screenMaterial)
      screen.castShadow = true
      screen.name = 'dashboardScreen' // Name it for raycasting
      dashboardGroup.add(screen)

      // Load the dashboard image
      // Place your dashboard screenshot as 'dashboard.png' in the same directory as this HTML file
      textureLoader.load(
        'public/dashboard.png',
        (texture) => {
          texture.colorSpace = THREE.SRGBColorSpace
          texture.minFilter = THREE.LinearFilter
          texture.magFilter = THREE.LinearFilter
          screenMaterial.uniforms.uTexture.value = texture
          screenMaterial.needsUpdate = true
          document.getElementById('loading').style.display = 'none'
        },
        undefined,
        (error) => {
          console.error(
            'Failed to load dashboard.png. Make sure the image file exists in the same directory.'
          )
          // Use a colored fallback if image fails to load
          screenMaterial.color = new THREE.Color(0x5a4d8a)
          screenMaterial.emissiveIntensity = 0.5
          screenMaterial.needsUpdate = true
          document.getElementById('loading').style.display = 'none'
        }
      )

      // Add glow effect behind screen
      const glowGeometry = new THREE.PlaneGeometry(screenWidth + 0.5, screenHeight + 0.5)
      const glowMaterial = new THREE.MeshBasicMaterial({
        color: 0x667eea,
        transparent: true,
        opacity: 0.3,
        side: THREE.DoubleSide,
      })
      const glow = new THREE.Mesh(glowGeometry, glowMaterial)
      glow.position.z = -0.1
      dashboardGroup.add(glow)

      scene.add(dashboardGroup)

      // Raycaster for click detection
      const raycaster = new THREE.Raycaster()
      const mouse = new THREE.Vector2()
      let activeRipple = null // Store active ripple state

      // Click handler for ripple effect
      window.addEventListener('click', (event) => {
        // Calculate mouse position in normalized device coordinates
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1

        // Update raycaster
        raycaster.setFromCamera(mouse, camera)

        // Check for intersections with the dashboard screen
        const intersects = raycaster.intersectObject(screen, false)

        if (intersects.length > 0) {
          const intersect = intersects[0]

          // Get UV coordinates at click point
          const uv = intersect.uv

          // Start new ripple
          activeRipple = {
            center: new THREE.Vector2(uv.x, uv.y),
            time: 0,
            maxTime: 1.5, // Duration in seconds
          }
        }
      })

      // Floating particles (stars)
      const particlesGeometry = new THREE.BufferGeometry()
      const particlesCount = 500
      const posArray = new Float32Array(particlesCount * 3)

      for (let i = 0; i < particlesCount * 3; i++) {
        posArray[i] = (Math.random() - 0.5) * 30
      }

      particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3))
      const particlesMaterial = new THREE.PointsMaterial({
        size: 0.03,
        color: 0x667eea,
        transparent: true,
        opacity: 0.6,
        blending: THREE.AdditiveBlending,
      })

      const particlesMesh = new THREE.Points(particlesGeometry, particlesMaterial)
      scene.add(particlesMesh)

      // Controls
      const keys = {
        forward: false,
        backward: false,
        left: false,
        right: false,
        turnLeft: false,
        turnRight: false,
        lookUp: false,
        lookDown: false,
      }

      document.addEventListener('keydown', (e) => {
        switch (e.code) {
          case 'KeyW':
            keys.forward = true
            break
          case 'KeyS':
            keys.backward = true
            break
          case 'KeyA':
            keys.left = true
            break
          case 'KeyD':
            keys.right = true
            break
          case 'ArrowLeft':
            keys.turnLeft = true
            break
          case 'ArrowRight':
            keys.turnRight = true
            break
          case 'ArrowUp':
            keys.lookUp = true
            break
          case 'ArrowDown':
            keys.lookDown = true
            break
        }
      })

      document.addEventListener('keyup', (e) => {
        switch (e.code) {
          case 'KeyW':
            keys.forward = false
            break
          case 'KeyS':
            keys.backward = false
            break
          case 'KeyA':
            keys.left = false
            break
          case 'KeyD':
            keys.right = false
            break
          case 'ArrowLeft':
            keys.turnLeft = false
            break
          case 'ArrowRight':
            keys.turnRight = false
            break
          case 'ArrowUp':
            keys.lookUp = false
            break
          case 'ArrowDown':
            keys.lookDown = false
            break
        }
      })

      // Hide click hint on first interaction
      document.addEventListener(
        'keydown',
        () => {
          document.getElementById('click-hint').classList.add('hidden')
        },
        { once: true }
      )

      // Animation
      let time = 0
      function animate() {
        requestAnimationFrame(animate)
        time += 0.01

        // Animate shader-based ripple
        if (activeRipple) {
          activeRipple.time += 0.016 // ~60fps

          const progress = activeRipple.time / activeRipple.maxTime

          if (progress < 1.0) {
            // Update shader uniforms
            screenMaterial.uniforms.uRippleCenter.value = activeRipple.center
            screenMaterial.uniforms.uRippleRadius.value = progress * 0.5 // Expand to 50% of screen
            screenMaterial.uniforms.uRippleStrength.value = (1.0 - progress) * 1.5 // Fade out
          } else {
            // Reset ripple
            screenMaterial.uniforms.uRippleStrength.value = 0.0
            activeRipple = null
          }
        }

        // Handle turning (Arrow Left/Right)
        if (keys.turnLeft) cameraRotation.y += turnSpeed
        if (keys.turnRight) cameraRotation.y -= turnSpeed

        // Handle looking up/down (Arrow Up/Down)
        if (keys.lookUp) cameraRotation.x += lookSpeed
        if (keys.lookDown) cameraRotation.x -= lookSpeed

        // Clamp vertical look angle
        cameraRotation.x = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, cameraRotation.x))

        // Update camera rotation
        camera.rotation.x = cameraRotation.x
        camera.rotation.y = cameraRotation.y

        // Calculate movement (WASD)
        const direction = new THREE.Vector3()

        if (keys.forward) direction.z -= 1
        if (keys.backward) direction.z += 1
        if (keys.left) direction.x -= 1
        if (keys.right) direction.x += 1

        if (direction.length() > 0) {
          direction.normalize()
          const euler = new THREE.Euler(0, cameraRotation.y, 0, 'YXZ')
          direction.applyEuler(euler)
          camera.position.add(direction.multiplyScalar(moveSpeed))
        }

        // Lock camera to ground level
        camera.position.y = cameraHeight

        // Animate particles
        particlesMesh.rotation.y += 0.0005

        // Animate accent lights
        accentLight1.intensity = 2 + Math.sin(time) * 0.5
        accentLight2.intensity = 2 + Math.cos(time) * 0.5

        // Pulse the glow
        glow.material.opacity = 0.2 + Math.sin(time * 2) * 0.1

        renderer.render(scene, camera)
      }

      // Handle window resize
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight
        camera.updateProjectionMatrix()
        renderer.setSize(window.innerWidth, window.innerHeight)
      })

      animate()
    </script>
  </body>
</html>
